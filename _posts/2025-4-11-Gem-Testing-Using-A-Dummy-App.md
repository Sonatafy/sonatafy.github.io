---
layout: post
title: Testing Rails Components with a Dummy App
---

I'm currently developing a Ruby gem called `ViewComponentGenerator`. While it's not yet released, its goal is to help developers quickly set up a View Component library in their Rails applications, complete with Tailwind CSS styling, Lookbook integration, and RSpec testing.

One of the core features I wanted to bake into this gem from the start was the ability to generate not just the component files, but also their associated unit and integration tests. This ensures that developers have a solid foundation for maintaining and extending their components. To achieve this, I've leaned heavily on the concept of a "dummy app" within the gem's testing setup.

## Why a Dummy App?

When testing a Rails gem that generates application code (like View Components), you need a real Rails environment to work with. That's where a dummy app comes in.

A dummy app is essentially a miniature Rails application that lives within your gem's test suite. It provides the necessary Rails infrastructure to:

* Render components.
* Run component-specific tests.
* Test integration with other tools (like Lookbook, in this case).

In the context of `ViewComponentGenerator`, the dummy app allows me to:

* Generate View Components into a realistic Rails application structure.
* Write and run RSpec tests that assert how these components behave.
* Test how the generated components are rendered within Lookbook.

## Setting Up the Dummy App

Here's a breakdown of how I set up and use the dummy app for testing `ViewComponentGenerator`:

**`rails_helper.rb`**: This file configures the test environment. Key elements include:

* Requiring necessary testing libraries (`view_component/test_helpers`, `capybara/rspec`, `rails/generators/test_case`).
* Configuring RSpec to include ViewComponent test helpers and Capybara matchers.
* Including Rails generator testing helpers.
* Regenerating test components before running the test suite. This is crucial: it ensures that the tests within the dummy app are always up-to-date with the latest component templates from the gem.

```ruby
# Key test dependencies
require 'view_component/test_helpers'
require 'capybara/rspec'
require 'rails/generators/test_case'

# RSpec configuration
RSpec.configure do |config|
  # ViewComponent test configuration
  config.include ViewComponent::TestHelpers, type: :component
  config.include Capybara::RSpecMatchers, type: :component

  # Generator test configuration
  config.include Rails::Generators::Testing::Behavior, type: :generator
  config.include Rails::Generators::Testing::SetupAndTeardown, type: :generator
  config.include Rails::Generators::Testing::Assertions, type: :generator
end
```

**Generator Tests**: These tests verify that the `rails generate view_component` command produces the expected files within the dummy app.

* I use `run_generator` to execute the generator within the test environment.
* Then, I read the generated files from the dummy app's file system and use RSpec matchers to assert their content. This includes checking for:
    * The correct component class definition.
    * Tailwind CSS classes in the template.
    * The presence of a spec file (the component unit test).
    * The presence of a Lookbook preview file (used for integration testing).

```ruby
it "generates a basic component with all required files" do
  run_generator ["button"]

  # Check component file
  component_file = File.read(File.join(destination_root, "app/components/button_component.rb"))
  expect(component_file).to match(/class ButtonComponent < ViewComponent::Base/)

  # Check template file with Tailwind classes
  template_file = File.read(File.join(destination_root, "app/components/button_component.html.erb"))
  expect(template_file).to match(/button.*class: tailwind_classes/)

  # Check component spec
  spec_file = File.read(File.join(destination_root, "spec/components/button_component_spec.rb"))
  expect(spec_file).to match(/RSpec.describe ButtonComponent, type: :component/)

  # Check Lookbook preview
  preview_file = File.read(File.read(File.join(destination_root, "app/components/previews/button_component_preview.rb")))
  expect(preview_file).to match(/class ButtonComponentPreview < Lookbook::Preview/)
end
```

**Component Unit Tests**: These tests, located within the dummy app's `spec/components` directory, focus on the behavior of individual components. It's important to understand that the code for these tests is generated by the gem. When I run the test suite, RSpec executes these generated tests within the context of the dummy Rails application.

* I use `render_inline` from the `view_component/test_helpers` gem to render the component within the dummy app.
* Then, I use Capybara matchers (e.g., `have_button`, `have_css`) to assert the rendered output. This allows me to check things like:
    * Basic rendering of the component.
    * Text displayed.
    * CSS classes applied (including Tailwind classes).
    * Handling of different component variants and sizes.
    * Custom CSS class injection.

```ruby
it "renders a button with text" do
  render_inline(described_class.new(text: "Click me"))

  expect(page).to have_button("Click me")
  expect(page).to have_css("button")
end

it "renders with primary variant by default" do
  render_inline(described_class.new(text: "Click me"))
  expect(page).to have_css("button.bg-indigo-600.text-white")
end

it "allows custom class injection" do
  custom_class = "custom-class"
  render_inline(described_class.new(text: "Click me", class_name: custom_class))
  expect(page).to have_css("button.#{custom_class}")
end
```

**Integration Tests**: These tests verify how components work with other parts of a Rails application, especially Lookbook. Like the unit tests, the code for these tests is generated by the gem and run within the dummy app.

```ruby
it "works with Lookbook preview" do
  preview_class = ButtonComponentPreview
  expect(preview_class.superclass).to eq(Lookbook::Preview)
  expect(preview_class.instance_methods(false)).to include(:primary)
end
```

## Key Takeaways

Using a dummy app has been crucial for effectively testing `ViewComponentGenerator`. It provides an isolated Rails environment that allows me to:

* Simulate real-world usage of the generated components.
* Generate test files into the dummy app, which RSpec then uses to validate the components.
* Verify integration with tools like Lookbook.

This approach ensures that `ViewComponentGenerator` creates components that are not only functional but also well-tested and ready to be used in a Rails application.
```
